/* Generated by RuntimeBrowser
   Image: /System/Library/PrivateFrameworks/AVFCore.framework/AVFCore
 */

@interface AVSampleBufferVideoRenderer : NSObject <AVMediaDataRequesterConsumer, AVQueuedSampleBufferRenderingInternal> {
    bool  _aboveHighWaterLevel;
    bool  _addedToSynchronizer;
    struct OpaqueCMTimebase { } * _controlTimebaseSetByUser;
    bool  _controlTimebaseSetByUserIsInUse;
    id  _didFinishSuspensionNotificationToken;
    NSError * _error;
    struct __CFArray { } * _figVideoTargets;
    NSObject<OS_dispatch_queue> * _flushCallbackListQueue;
    NSObject<OS_dispatch_queue> * _flushCallbackQueue;
    NSMutableArray * _flushCallbacks;
    bool  _hasEverEnqueued;
    bool  _isRequestingMediaData;
    NSObject<OS_dispatch_queue> * _layerQueue;
    AVMediaDataRequester * _mediaDataRequester;
    struct { 
        long long value; 
        int timescale; 
        unsigned int flags; 
        long long epoch; 
    }  _minimumUpcomingPTS;
    bool  _outputObscured;
    id /* block */  _pendingPrerollCompleteCallback;
    int  _pendingPrerollRequestID;
    bool  _preventsDisplaySleepDuringVideoPlayback;
    NSObject<OS_dispatch_queue> * _queueForCallingPrerollCompleteCallback;
    NSObject<OS_dispatch_queue> * _queueForProtectingPrerollCompleteCallback;
    struct OpaqueCMTimebase { } * _readOnlyRenderingTimebase;
    struct OpaqueCMTimebase { } * _readOnlyVideoQueueTimebase;
    bool  _requiresFlushToResumeDecoding;
    NSObject<OS_dispatch_queue> * _serialQueue;
    long long  _status;
    int  _upcomingPTSExpectation;
    NSMutableArray * _videoOutputs;
    struct OpaqueFigVideoQueue { } * _videoQueue;
    NSObject<OS_dispatch_queue> * _videoQueueQueue;
    AVSampleBufferDisplayLayer * _weakDisplayLayer;
    AVSampleBufferRenderSynchronizer * _weakReferenceToSynchronizer;
}

@property (readonly, copy) NSString *debugDescription;
@property (readonly, copy) NSString *description;
@property (readonly) unsigned long long hash;
@property (readonly) bool outputObscuredDueToInsufficientExternalProtection;
@property (nonatomic, readonly) NSArray *outputs;
@property (nonatomic) bool preventsCapture;
@property (nonatomic) bool preventsDisplaySleepDuringVideoPlayback;
@property (readonly) Class superclass;

+ (bool)automaticallyNotifiesObserversForKey:(id)arg1;
+ (void)initialize;

- (void).cxx_destruct;
- (void)_addFigVideoQueueListeners;
- (void)_callOldPrerollCompletionHandlerWithSuccess:(bool)arg1 andSetNewPrerollCompletionHandler:(id /* block */)arg2 forRequestID:(int)arg3;
- (void)_completedDecodeForPrerollForRequestID:(int)arg1;
- (struct OpaqueFigVideoQueue { }*)_copyVideoQueue;
- (int)_createVideoQueue:(struct OpaqueFigVideoQueue {}**)arg1;
- (void)_didFinishSuspension:(id)arg1;
- (int)_enqueueSingleSampleBuffer:(struct opaqueCMSampleBuffer { }*)arg1 bufferEnqueueingInfo:(struct { struct CGRect { struct CGPoint { double x_1_2_1; double x_1_2_2; } x_1_1_1; struct CGSize { double x_2_2_1; double x_2_2_2; } x_1_1_2; } x1; struct CGRect { struct CGPoint { double x_1_2_1; double x_1_2_2; } x_2_1_1; struct CGSize { double x_2_2_1; double x_2_2_2; } x_2_1_2; } x2; }*)arg2;
- (void)_flushComplete;
- (bool)_hasEverEnqueued;
- (int)_initializeTimebases;
- (struct OpaqueCMTimebase { }*)_readOnlyVideoQueueTimebase;
- (void)_refreshAboveHighWaterLevel;
- (void)_removeFigVideoQueueListeners;
- (void)_resetStatusWithOSStatus:(int)arg1;
- (int)_setContentLayerOnFigVideoQueue:(struct OpaqueFigVideoQueue { }*)arg1;
- (void)_setOutputObscuredDueToInsufficientExternalProtection:(bool)arg1;
- (void)_setRequiresFlushToResumeDecoding:(bool)arg1;
- (void)_setStatus:(long long)arg1 error:(id)arg2;
- (bool)_setSynchronizerTimebase:(struct OpaqueCMTimebase { }*)arg1 error:(id*)arg2;
- (bool)_setUpcomingPresentationTimeExpectations:(int)arg1 minimumPresentationTime:(struct { long long x1; int x2; unsigned int x3; long long x4; })arg2;
- (void)_updateVideoOutputs;
- (void)_updateVideoTargetsOnVideoQueue;
- (void)addOutput:(id)arg1;
- (void)addSampleBufferDisplayLayer:(id)arg1;
- (void)addVideoTarget:(struct OpaqueFigVideoTarget { }*)arg1;
- (struct OpaqueCMTimebase { }*)controlTimebase;
- (void)copyFigSampleBufferAudioRenderer:(struct OpaqueFigSampleBufferAudioRenderer {}**)arg1;
- (void)dealloc;
- (id)description;
- (void)enqueueSampleBuffer:(struct opaqueCMSampleBuffer { }*)arg1;
- (void)enqueueSampleBuffer:(struct opaqueCMSampleBuffer { }*)arg1 bufferEnqueueingInfo:(struct { struct CGRect { struct CGPoint { double x_1_2_1; double x_1_2_2; } x_1_1_1; struct CGSize { double x_2_2_1; double x_2_2_2; } x_1_1_2; } x1; struct CGRect { struct CGPoint { double x_1_2_1; double x_1_2_2; } x_2_1_1; struct CGSize { double x_2_2_1; double x_2_2_2; } x_2_1_2; } x2; }*)arg2;
- (id)error;
- (void)expectMinimumUpcomingSampleBufferPresentationTime:(struct { long long x1; int x2; unsigned int x3; long long x4; })arg1;
- (void)expectMonotonicallyIncreasingUpcomingSampleBufferPresentationTimes;
- (void)flush;
- (void)flushAndRemoveImage;
- (void)flushWithRemovalOfDisplayedImage:(bool)arg1 completionHandler:(id /* block */)arg2;
- (bool)hasSufficientMediaDataForReliablePlaybackStart;
- (id)init;
- (bool)isReadyForMoreMediaData;
- (bool)outputObscuredDueToInsufficientExternalProtection;
- (id)outputs;
- (void)prerollDecodeWithCompletionHandler:(id /* block */)arg1;
- (bool)preventsCapture;
- (bool)preventsDisplaySleepDuringVideoPlayback;
- (void)removeOutput:(id)arg1;
- (void)requestMediaDataWhenReadyOnQueue:(id)arg1 usingBlock:(id /* block */)arg2;
- (bool)requiresFlushToResumeDecoding;
- (void)resetUpcomingSampleBufferPresentationTimeExpectations;
- (void)setControlTimebase:(struct OpaqueCMTimebase { }*)arg1;
- (void)setDisplayLayerVisibility:(bool)arg1;
- (void)setPreventsCapture:(bool)arg1;
- (void)setPreventsDisplaySleepDuringVideoPlayback:(bool)arg1;
- (bool)setRenderSynchronizer:(id)arg1 error:(id*)arg2;
- (void)setSTSLabel:(id)arg1;
- (void)setToneMapToStandardDynamicRange:(bool)arg1;
- (long long)status;
- (void)stopRequestingMediaData;
- (struct OpaqueCMTimebase { }*)timebase;
- (id)videoPerformanceMetrics;

@end
