/* Generated by RuntimeBrowser
   Image: /System/Library/PrivateFrameworks/AVFCore.framework/AVFCore
 */

@interface AVPlayerInternal : NSObject {
    void * IAPDCallbackToken;
    bool  IOwnTheFigPlayer;
    <AVBlockScheduler> * KVOChangeSerializer;
    bool  PIPModePossible;
    NSString * STSLabel;
    long long  actionAtItemEnd;
    bool  airPlayVideoActive;
    bool  allowsExternalPlayback;
    bool  allowsOutOfBandTextTrackRendering;
    bool  allowsPixelBufferPoolSharing;
    NSString * ancillaryPerformanceInformationForDisplay;
    bool  appliesMediaSelectionCriteriaAutomatically;
    NSString * audioOutputDeviceUniqueID;
    AVAudioSession * audioSession;
    AVAudioSessionMediaPlayerOnly * audioSessionMediaPlayerOnly;
    long long  audiovisualBackgroundPlaybackPolicy;
    bool  autoSwitchStreamVariants;
    bool  automaticallyWaitsToMinimizeStalling;
    NSHashTable * avPlayerLayers;
    NSString * backgroundPIPAuthorizationToken;
    NSDictionary * cachedFigMediaSelectionCriteriaProperty;
    NSString * captionPipelineStrategy;
    NSString * captionRenderingStrategy;
    NSString * clientName;
    long long  clientPriority;
    bool  clientRequestedPlaybackCoordinator;
    bool  closedCaptionDisplayEnabled;
    NSMutableArray * closedCaptionLayers;
    NSObject<OS_dispatch_queue> * configurationQueue;
    AVPlayerItem * currentItem;
    bool  currentItemNonForcedSubtitlesEnabled;
    id  currentItemPreferredPixelBufferAttributesNotificationToken;
    struct CGSize { 
        double width; 
        double height; 
    }  currentItemPresentationSize;
    NSObject<OS_dispatch_queue> * currentItemPropertyUpdateQueue;
    id  currentItemSuppressesVideoLayersNotificationToken;
    id  didEnterBackgroundNotificationToken;
    id  didFinishSuspensionNotificationToken;
    struct CGSize { 
        double width; 
        double height; 
    }  dimensionsOfReservedVideoMemory;
    bool  disallowsAMRAudio;
    bool  disallowsAutoPauseOnRouteRemovalIfNoAudio;
    bool  disallowsHardwareAcceleratedVideoDecoder;
    bool  disallowsVideoLayerDisplayCompositing;
    NSArray * displaysUsedForPlayback;
    bool  dynamicallyChoosesInitialVariant;
    bool  ensuresActiveAudioSessionWhenStartingPlayback;
    NSError * error;
    NSArray * expectedAssetTypes;
    bool  externalPlaybackActive;
    NSString * externalPlaybackVideoGravity;
    long long  externalProtectionStatus;
    NSObject<OS_dispatch_queue> * figConfigurationQueue;
    struct OpaqueCMClock { } * figMasterClock;
    struct OpaqueFigPlaybackItem { } * figPlaybackItemToIdentifyNextCurrentItem;
    struct OpaqueFigPlayer { } * figPlayer;
    bool  fullyInitializedAndNotDeallocating;
    bool  hadAssociatedOnscreenPlayerLayerWhenSuspended;
    NSMutableArray * handlersToCallWhenReadyToPlay;
    bool  hostApplicationInForeground;
    struct OpaqueFigPlayerInterstitialCoordinator { } * interstitialEventCoordinator;
    AVQueuePlayer * interstitialPlayer;
    bool  isConnectedToPhysicalSecondScreen;
    bool  isDisplayingClosedCaptions;
    bool  isInterstitialPlayer;
    bool  isSilencedDueToConflictWithOtherPlayback;
    NSMutableSet * items;
    NSArray * itemsInFigPlayQueue;
    NSObject<OS_dispatch_queue> * ivarAccessQueue;
    AVPlayerItem * lastItem;
    bool  layerDestinationIsTVOut;
    id  layerForegroundingChangeToken;
    NSObject<OS_dispatch_queue> * layerInteractionQueue;
    NSObject<OS_dispatch_queue> * layersQ;
    bool  limitsBandwidthForCellularAccess;
    bool  logPerformanceData;
    <AVLoggingIdentifier> * loggingIdentifier;
    float  maxRateForAudioPlayback;
    float  minRateForAudioPlayback;
    NSString * multichannelAudioStrategy;
    bool  muted;
    NSNumber * mxSessionID;
    bool  needsToCreateFigPlayer;
    int  nextPrerollIDToGenerate;
    AVOutputContext * outputContext;
    bool  outputObscuredDueToInsufficientExternalProtection;
    NSMutableDictionary * pendingFigPlayerProperties;
    int  pendingPrerollID;
    AVPixelBufferAttributeMediator * pixelBufferAttributeMediator;
    AVPlayerPlaybackCoordinator * playbackCoordinator;
    NSString * playerRole;
    unsigned long long  preferredVideoDecoderGPURegistryID;
    bool  prefersPlayingSilentlyWhenConflictingWithOtherPlayback;
    bool  preparesItemsForPlaybackAsynchronously;
    id /* block */  prerollCompletionHandler;
    struct OpaqueFigSimpleMutex { } * prerollIDMutex;
    bool  preservesAudioSessionSampleRate;
    bool  preventsDisplaySleepDuringVideoPlayback;
    struct OpaqueCMTimebase { } * proxyTimebase;
    NSArray * queueModifications;
    float  rate;
    int  rateChangeIdentifier;
    bool  rateDidChangeNotificationIncludesExtendedDiagnosticPayload;
    bool  rateUpdateDuringTransitionDecided;
    NSString * reasonForWaitingToPlay;
    bool  reevaluateBackgroundPlayback;
    long long  resourceConservationLevelWhilePaused;
    bool  shouldReduceResourceUsage;
    bool  silencesOtherPlaybackDuringPIP;
    NSObject<OS_dispatch_queue> * stateDispatchQueue;
    long long  status;
    NSMutableArray * subtitleLayers;
    bool  suppressesAudioRendering;
    bool  suspensionExpected;
    long long  timeControlStatus;
    float  userVolume;
    bool  usesAudioOnlyModeForExternalPlayback;
    bool  usesDedicatedNotificationQueueForMediaServices;
    bool  usesExternalPlaybackWhileExternalScreenIsActive;
    bool  usesLegacyAutomaticWaitingBehavior;
    NSDictionary * vibrationPattern;
    NSMutableArray * videoLayers;
    bool  videoLayersAreAttached;
    NSArray * videoTargets;
    float  volume;
    AVWeakReference * weakReference;
    id  willEnterForegroundNotificationToken;
}

@end
